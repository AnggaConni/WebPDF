<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebPDF Editor Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://unpkg.com/downloadjs@1.4.7/download.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/signature_pad@4.1.7/dist/signature_pad.umd.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #e5e7eb; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        .canvas-container {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            margin: 0 auto;
            transition: transform 0.1s ease-out;
        }
        #interaction-layer {
            position: absolute; top: 0; left: 0; z-index: 10; cursor: crosshair;
        }
        .tool-active { background-color: #dbeafe; border-color: #3b82f6; color: #1d4ed8; }
        .page-thumb-active { border: 2px solid #3b82f6; background-color: #eff6ff; }
        
        .loader {
            border: 3px solid #f3f3f3; border-top: 3px solid #3498db;
            border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Floating Input */
        #text-input-container {
            position: absolute;
            display: none;
            z-index: 100;
        }
        #floating-textarea {
            background: rgba(255, 255, 255, 0.9);
            border: 1px dashed #3b82f6;
            padding: 4px;
            outline: none;
            resize: none;
            overflow: hidden;
            line-height: 1.2;
            min-width: 50px;
            white-space: pre-wrap;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            top: 80px;
            right: 20px;
            background: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideIn 0.3s ease-out;
            z-index: 1000;
        }
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .toast.success { border-left: 4px solid #10b981; }
        .toast.error { border-left: 4px solid #ef4444; }
        .toast.info { border-left: 4px solid #3b82f6; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden text-gray-800">

    <!-- Header -->
    <header class="bg-white border-b border-gray-200 z-20 shadow-sm flex flex-col flex-shrink-0">
        <!-- Top Toolbar -->
        <div class="flex justify-between items-center px-4 py-2">
            <!-- Left -->
            <div class="flex items-center space-x-3 w-1/4">
                <button onclick="toggleSidebar()" class="p-2 hover:bg-gray-100 rounded text-gray-600" title="Toggle Sidebar">
                    <i data-lucide="panel-left" class="w-5 h-5"></i>
                </button>
                <div class="flex items-center space-x-2">
                    <div class="bg-blue-600 text-white p-1 rounded">
                        <i data-lucide="file-text" class="w-5 h-5"></i>
                    </div>
                    <h1 class="font-bold text-gray-800 text-lg hidden lg:block">WebPDF</h1>
                </div>
            </div>
            
            <!-- Center: Tools -->
            <div class="flex space-x-1 bg-gray-100 p-1 rounded-lg shadow-inner relative" id="toolbar">
                <button onclick="setMode('cursor')" id="btn-cursor" class="p-2 rounded hover:bg-white transition tool-active" title="Select / Move / Resize (V)">
                    <i data-lucide="mouse-pointer-2" class="w-5 h-5"></i>
                </button>
                <button onclick="setMode('text')" id="btn-text" class="p-2 rounded hover:bg-white transition" title="Add Text (T)">
                    <i data-lucide="type" class="w-5 h-5"></i>
                </button>
                <button onclick="setMode('draw')" id="btn-draw" class="p-2 rounded hover:bg-white transition" title="Draw (D)">
                    <i data-lucide="pen-tool" class="w-5 h-5"></i>
                </button>
                
                <!-- STAMP TOOL -->
                <div class="relative">
                    <button onclick="toggleStampMenu()" id="btn-stamp" class="p-2 rounded hover:bg-white transition" title="Add Stamp (S)">
                        <i data-lucide="stamp" class="w-5 h-5"></i>
                    </button>
                    <!-- Dropdown Menu -->
                    <div id="stamp-menu" class="hidden absolute top-full left-1/2 transform -translate-x-1/2 mt-2 w-48 bg-white rounded-md shadow-lg z-50 border border-gray-200 p-1">
                        <button onclick="addStamp('APPROVED', '#10b981')" class="block w-full text-left px-4 py-2 hover:bg-gray-100 text-sm font-bold text-green-600 rounded">APPROVED</button>
                        <button onclick="addStamp('REJECTED', '#ef4444')" class="block w-full text-left px-4 py-2 hover:bg-gray-100 text-sm font-bold text-red-600 rounded">REJECTED</button>
                        <button onclick="addStamp('DRAFT', '#6b7280')" class="block w-full text-left px-4 py-2 hover:bg-gray-100 text-sm font-bold text-gray-500 rounded">DRAFT</button>
                        <button onclick="addStamp('CONFIDENTIAL', '#dc2626')" class="block w-full text-left px-4 py-2 hover:bg-gray-100 text-sm font-bold text-red-700 rounded">CONFIDENTIAL</button>
                        <button onclick="addStamp('URGENT', '#f59e0b')" class="block w-full text-left px-4 py-2 hover:bg-gray-100 text-sm font-bold text-orange-600 rounded">URGENT</button>
                        <button onclick="addStamp('VOID', '#9ca3af')" class="block w-full text-left px-4 py-2 hover:bg-gray-100 text-sm font-bold text-gray-400 rounded">VOID</button>
                        <div class="border-t my-1"></div>
                        <button onclick="document.getElementById('stamp-upload').click()" class="block w-full text-left px-4 py-2 hover:bg-gray-100 text-sm flex items-center gap-2 rounded">
                            <i data-lucide="image-plus" class="w-4 h-4"></i> Import PNG
                        </button>
                    </div>
                </div>

                <button onclick="setMode('whiteout')" id="btn-whiteout" class="p-2 rounded hover:bg-white transition text-red-500" title="Eraser / Whiteout (E)">
                    <i data-lucide="eraser" class="w-5 h-5"></i>
                </button>
                <div class="w-px bg-gray-300 mx-2"></div>
                <button onclick="openSignatureModal()" class="p-2 rounded hover:bg-white transition text-purple-600" title="Signature">
                    <i data-lucide="signature" class="w-5 h-5"></i>
                </button>
                <button onclick="document.getElementById('image-upload').click()" class="p-2 rounded hover:bg-white transition text-green-600" title="Insert Image (I)">
                    <i data-lucide="image" class="w-5 h-5"></i>
                </button>
                <div class="w-px bg-gray-300 mx-2"></div>
                <button onclick="undo()" id="btn-undo" class="p-2 rounded hover:bg-white transition text-gray-600 disabled:opacity-30" title="Undo (Ctrl+Z)" disabled>
                    <i data-lucide="undo" class="w-5 h-5"></i>
                </button>
                <button onclick="redo()" id="btn-redo" class="p-2 rounded hover:bg-white transition text-gray-600 disabled:opacity-30" title="Redo (Ctrl+Y)" disabled>
                    <i data-lucide="redo" class="w-5 h-5"></i>
                </button>
            </div>

            <!-- Right: Actions -->
            <div class="flex justify-end space-x-2 w-1/4">
                <input type="file" id="file-upload" accept="application/pdf" class="hidden" onchange="handleFileUpload(event)">
                <input type="file" id="image-upload" accept="image/png, image/jpeg" class="hidden" onchange="handleImageUpload(event)">
                <input type="file" id="stamp-upload" accept="image/png" class="hidden" onchange="handleStampUpload(event)">
                <input type="file" id="insert-pdf-upload" accept="application/pdf" class="hidden" onchange="handleInsertPdfUpload(event)">
                
                <button onclick="document.getElementById('file-upload').click()" class="flex items-center space-x-1 px-3 py-1.5 bg-white border border-gray-300 text-gray-700 rounded hover:bg-gray-50 text-sm font-medium">
                    <i data-lucide="folder-open" class="w-4 h-4"></i>
                    <span class="hidden xl:inline">Open</span>
                </button>
                <button onclick="savePdf()" class="flex items-center space-x-1 px-3 py-1.5 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm font-medium shadow-sm">
                    <i data-lucide="download" class="w-4 h-4"></i>
                    <span class="hidden xl:inline">Save</span>
                </button>
            </div>
        </div>

        <!-- Property Bar -->
        <div class="px-4 py-2 bg-gray-50 border-t border-gray-200 flex justify-between items-center text-xs h-12">
            
            <div class="flex items-center space-x-4 flex-1">
                 <!-- Text Properties -->
                <div id="prop-text" class="hidden items-center space-x-3">
                    <span class="font-bold text-gray-500 uppercase">Text:</span>
                    <select id="text-font" class="border rounded px-2 py-1 bg-white" onchange="updateSelectedTextProp()">
                        <option value="Helvetica">Helvetica</option>
                        <option value="Times-Roman">Times New Roman</option>
                        <option value="Courier">Courier</option>
                    </select>
                    <div class="flex items-center space-x-1">
                        <span>Size:</span>
                        <input type="number" id="text-size" value="12" min="8" max="72" class="border rounded w-12 px-1 py-1" onchange="updateSelectedTextProp()">
                    </div>
                    <input type="color" id="text-color" value="#000000" class="h-6 w-6 border-none cursor-pointer rounded" onchange="updateSelectedTextProp()">
                    <button onclick="deleteSelectedAnnotation()" id="btn-delete-text" class="text-red-500 hover:text-red-700 ml-2 hidden" title="Delete Selected">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                    </button>
                </div>

                <!-- Stamp Properties -->
                <div id="prop-stamp" class="hidden items-center space-x-3">
                    <span class="font-bold text-gray-500 uppercase">Stamp:</span>
                    <input type="color" id="stamp-color" value="#10b981" class="h-6 w-6 border-none cursor-pointer rounded" onchange="updateSelectedStampProp()">
                    <button onclick="deleteSelectedAnnotation()" class="text-red-500 hover:text-red-700 ml-2" title="Delete Selected">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                    </button>
                </div>

                <!-- Eraser Props -->
                <div id="prop-whiteout" class="hidden items-center space-x-3">
                    <span class="font-bold text-gray-500 uppercase">Eraser Size:</span>
                    <input type="range" id="eraser-size" min="10" max="100" value="30" class="w-24 h-1.5 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>
                <!-- Draw Props -->
                 <div id="prop-draw" class="hidden items-center space-x-3">
                    <span class="font-bold text-gray-500 uppercase">Pen:</span>
                    <input type="color" id="pen-color" value="#0000FF" class="h-6 w-6 border-none cursor-pointer rounded">
                    <input type="range" id="pen-width" min="1" max="10" value="2" class="w-20 h-1.5 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <span class="text-xs text-gray-500">Width: <span id="pen-width-display">2</span>px</span>
                </div>
                <!-- Default / Info -->
                <div id="prop-default" class="flex items-center space-x-3 text-gray-500">
                    <span id="tool-hint">Cursor Mode: Drag to move. Drag blue corner to resize. Double click text to edit.</span>
                </div>
            </div>

            <!-- ZOOM -->
            <div class="flex items-center space-x-2 bg-white px-2 py-1 rounded border border-gray-300 shadow-sm">
                <button onclick="zoomOut()" class="p-1 hover:bg-gray-100 rounded text-gray-600" title="Zoom Out (-)">
                    <i data-lucide="minus" class="w-4 h-4"></i>
                </button>
                <span id="zoom-level" class="w-12 text-center font-mono font-medium text-gray-700">100%</span>
                <button onclick="zoomIn()" class="p-1 hover:bg-gray-100 rounded text-gray-600" title="Zoom In (+)">
                    <i data-lucide="plus" class="w-4 h-4"></i>
                </button>
            </div>

        </div>
    </header>

    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- Sidebar Navigation -->
        <aside id="sidebar-panel" class="w-64 bg-gray-100 border-r border-gray-200 flex flex-col hidden flex-shrink-0 transition-all duration-300 z-10">
            <!-- Sidebar Header -->
            <div class="p-3 border-b border-gray-200 bg-white shadow-sm sticky top-0 z-10">
                <div class="flex justify-between items-center mb-2">
                    <span class="font-semibold text-xs text-gray-600 uppercase tracking-wider">Pages</span>
                    <div class="flex gap-1">
                        <button onclick="prevPage()" class="p-1 hover:bg-gray-100 rounded text-gray-600" title="Previous Page (←)">
                            <i data-lucide="chevron-left" class="w-4 h-4"></i>
                        </button>
                        <button onclick="nextPage()" class="p-1 hover:bg-gray-100 rounded text-gray-600" title="Next Page (→)">
                            <i data-lucide="chevron-right" class="w-4 h-4"></i>
                        </button>
                    </div>
                </div>
                <!-- Insert Actions -->
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="promptInsertBlank()" class="flex items-center justify-center space-x-1 bg-white border border-gray-300 hover:bg-gray-50 text-gray-700 px-2 py-1.5 rounded text-xs transition shadow-sm">
                        <i data-lucide="file-plus" class="w-3 h-3"></i> <span>+ Blank</span>
                    </button>
                    <button onclick="promptInsertPdf()" class="flex items-center justify-center space-x-1 bg-white border border-gray-300 hover:bg-gray-50 text-gray-700 px-2 py-1.5 rounded text-xs transition shadow-sm">
                        <i data-lucide="file-up" class="w-3 h-3"></i> <span>+ PDF</span>
                    </button>
                </div>
            </div>
            <!-- Thumbnails -->
            <div id="thumbnail-container" class="flex-1 overflow-y-auto p-4 space-y-4">
                <div class="text-center text-gray-400 text-xs mt-10">Loading Pages...</div>
            </div>
        </aside>

        <!-- Canvas Workspace -->
        <main class="flex-1 bg-gray-200 relative overflow-auto flex justify-center p-8 transition-colors" id="main-scroll">
            
            <div id="empty-state" class="absolute inset-0 flex items-center justify-center bg-gray-50 z-0">
                <div class="text-center p-8 max-w-lg">
                    <div class="bg-white p-4 rounded-full inline-block shadow-sm mb-4">
                        <i data-lucide="upload-cloud" class="w-12 h-12 text-blue-500"></i>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800 mb-2">WebPDF Editor Pro</h2>
                    <p class="text-gray-500 mb-4 text-sm">Upload PDF to start editing.</p>
                    <p class="text-xs text-gray-400 mb-6">
                        <strong>Keyboard Shortcuts:</strong><br>
                        V: Cursor | T: Text | D: Draw | S: Stamp | E: Eraser | I: Image<br>
                        Ctrl+Z: Undo | Ctrl+Y: Redo | Delete: Remove | ←→: Navigate Pages
                    </p>
                    <button onclick="document.getElementById('file-upload').click()" class="px-6 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 shadow-md transition transform hover:-translate-y-0.5">
                        Select PDF File
                    </button>
                </div>
            </div>

            <div id="editor-area" class="hidden flex-col items-center relative z-0 mb-40 origin-top">
                <div class="canvas-container bg-white relative shadow-lg">
                    <canvas id="pdf-render"></canvas>
                    <canvas id="interaction-layer"></canvas>
                    
                    <!-- Floating Input -->
                    <div id="text-input-container">
                        <textarea id="floating-textarea" rows="1"></textarea>
                        <div class="flex justify-end mt-1 space-x-1">
                            <button onclick="cancelTextInput()" class="bg-gray-200 hover:bg-gray-300 text-gray-600 px-2 py-0.5 rounded text-xs">Cancel</button>
                            <button onclick="finalizeTextInput()" class="bg-blue-600 hover:bg-blue-700 text-white px-2 py-0.5 rounded text-xs">OK</button>
                        </div>
                    </div>

                </div>
                <div class="text-xs text-gray-500 mt-3 font-medium bg-white px-3 py-1 rounded-full shadow-sm" id="page-info-display">
                    Page 1 / 1
                </div>
            </div>

        </main>
    </div>

    <!-- Modals -->
    <div id="signature-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md mx-4">
            <div class="p-4 border-b flex justify-between items-center">
                <h3 class="font-semibold text-gray-800">Create Signature</h3>
                <button onclick="closeSignatureModal()" class="text-gray-400 hover:text-gray-600"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
            <div class="p-4 bg-gray-50">
                <div class="bg-white border-2 border-dashed border-gray-300 rounded-lg cursor-crosshair">
                    <canvas id="signature-pad" class="w-full h-48 touch-none"></canvas>
                </div>
            </div>
            <div class="p-4 border-t flex justify-between">
                <button onclick="clearSignature()" class="text-red-600 text-sm hover:underline font-medium">Clear</button>
                <button onclick="saveSignature()" class="bg-blue-600 text-white px-5 py-2 rounded text-sm font-medium hover:bg-blue-700 shadow">Use Signature</button>
            </div>
        </div>
    </div>

    <div id="insert-pdf-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-sm mx-4 p-6">
            <h3 class="font-bold text-lg mb-4">Insert PDF</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-xs font-semibold text-gray-500 mb-1">Select Pages (e.g., 1, 3-5):</label>
                    <input type="text" id="insert-range" placeholder="Leave empty for all pages" class="w-full border rounded px-2 py-1.5 text-sm">
                </div>
                <div>
                    <label class="block text-xs font-semibold text-gray-500 mb-1">Insert After Page:</label>
                    <input type="number" id="insert-after-page" class="w-full border rounded px-2 py-1.5 text-sm">
                </div>
                <div class="flex justify-end space-x-2 pt-2">
                    <button onclick="document.getElementById('insert-pdf-modal').classList.add('hidden')" class="px-3 py-1.5 text-sm text-gray-600 hover:bg-gray-100 rounded">Cancel</button>
                    <button onclick="document.getElementById('insert-pdf-upload').click()" class="px-3 py-1.5 text-sm bg-blue-600 text-white hover:bg-blue-700 rounded">Select File</button>
                </div>
            </div>
        </div>
    </div>

    <div id="loading-overlay" class="fixed inset-0 bg-white bg-opacity-90 hidden z-50 flex items-center justify-center flex-col">
        <div class="loader mb-3"></div>
        <p class="text-gray-600 text-sm font-medium animate-pulse" id="loading-text">Processing...</p>
    </div>

    <script>
        // --- Setup ---
        const { PDFDocument, rgb, StandardFonts, degrees } = PDFLib;
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
        lucide.createIcons();

        // State
        let pdfDoc = null; 
        let pdfBytes = null; 
        let pageNum = 1;
        let totalPages = 0;
        let pdfScale = 1.0; 
        let currentMode = 'cursor'; 
        let annotations = []; 
        let selectedAnnIndex = -1;
        
        // Undo/Redo
        let undoStack = [];
        let redoStack = [];
        
        // Interactions
        let isDragging = false;
        let isResizing = false;
        let dragStart = {x: 0, y: 0};
        let dragOffset = {x: 0, y: 0};
        
        let isSidebarOpen = true;
        let signaturePad = null;
        let pendingImage = null; 
        
        // DOM Elements
        const canvas = document.getElementById('pdf-render');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('interaction-layer');
        const overlayCtx = overlay.getContext('2d');
        const textInputContainer = document.getElementById('text-input-container');
        const floatingTextarea = document.getElementById('floating-textarea');
        const sidebarPanel = document.getElementById('sidebar-panel');
        const zoomDisplay = document.getElementById('zoom-level');
        const inputs = {
            font: document.getElementById('text-font'),
            size: document.getElementById('text-size'),
            color: document.getElementById('text-color'),
            eraser: document.getElementById('eraser-size'),
            pen: document.getElementById('pen-color'),
            penWidth: document.getElementById('pen-width'),
            stampColor: document.getElementById('stamp-color')
        };

        // Update pen width display
        inputs.penWidth.oninput = () => {
            document.getElementById('pen-width-display').textContent = inputs.penWidth.value;
        };

        // --- Toast Notifications ---
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <i data-lucide="${type === 'success' ? 'check-circle' : type === 'error' ? 'alert-circle' : 'info'}" class="w-5 h-5 ${type === 'success' ? 'text-green-600' : type === 'error' ? 'text-red-600' : 'text-blue-600'}"></i>
                <span class="font-medium">${message}</span>
            `;
            document.body.appendChild(toast);
            lucide.createIcons();
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(400px)';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // --- Undo/Redo System ---
        function saveState() {
            undoStack.push(JSON.parse(JSON.stringify(annotations)));
            redoStack = []; // Clear redo when new action
            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length === 0) return;
            redoStack.push(JSON.parse(JSON.stringify(annotations)));
            annotations = undoStack.pop();
            selectedAnnIndex = -1;
            updateToolbarForSelection();
            redrawOverlay();
            updateUndoRedoButtons();
            showToast('Undo', 'info');
        }

        function redo() {
            if (redoStack.length === 0) return;
            undoStack.push(JSON.parse(JSON.stringify(annotations)));
            annotations = redoStack.pop();
            selectedAnnIndex = -1;
            updateToolbarForSelection();
            redrawOverlay();
            updateUndoRedoButtons();
            showToast('Redo', 'info');
        }

        function updateUndoRedoButtons() {
            document.getElementById('btn-undo').disabled = undoStack.length === 0;
            document.getElementById('btn-redo').disabled = redoStack.length === 0;
        }

        // --- Keyboard Shortcuts ---
        window.addEventListener('keydown', (e) => {
            // Ignore if typing in input
            if (textInputContainer.style.display === 'block') return;
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            // Tool shortcuts
            if (e.key.toLowerCase() === 'v') setMode('cursor');
            else if (e.key.toLowerCase() === 't') setMode('text');
            else if (e.key.toLowerCase() === 'd') setMode('draw');
            else if (e.key.toLowerCase() === 's' && !e.ctrlKey && !e.metaKey) setMode('stamp');
            else if (e.key.toLowerCase() === 'e') setMode('whiteout');
            else if (e.key.toLowerCase() === 'i') document.getElementById('image-upload').click();
            
            // Undo/Redo
            else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                undo();
            }
            else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
                e.preventDefault();
                redo();
            }
            
            // Delete
            else if ((e.key === 'Delete' || e.key === 'Backspace') && selectedAnnIndex !== -1) {
                e.preventDefault();
                deleteSelectedAnnotation();
            }
            
            // Navigation
            else if (e.key === 'ArrowLeft') prevPage();
            else if (e.key === 'ArrowRight') nextPage();
            
            // Zoom
            else if (e.key === '+' || e.key === '=') zoomIn();
            else if (e.key === '-') zoomOut();
        });

        // --- Core Functions ---
        async function initPdf() {
            try {
                pdfDoc = await PDFDocument.load(pdfBytes);
                totalPages = pdfDoc.getPageCount();
                pageNum = 1;
                annotations = [];
                undoStack = [];
                redoStack = [];
                pdfScale = 1.0;
                updateZoomDisplay();
                updateUndoRedoButtons();
                
                document.getElementById('empty-state').classList.add('hidden');
                sidebarPanel.classList.remove('hidden'); sidebarPanel.classList.add('flex');
                document.getElementById('editor-area').classList.remove('hidden'); document.getElementById('editor-area').classList.add('flex');

                await renderPage(pageNum);
                await renderSidebar();
                showToast('PDF loaded successfully!', 'success');
            } catch (e) { 
                showToast('Error loading PDF: ' + e.message, 'error');
                console.error(e); 
            }
        }

        async function renderPage(num) {
            if (!pdfBytes) return;
            pageNum = num;
            document.getElementById('page-info-display').textContent = `Page ${num} / ${totalPages}`;
            document.querySelectorAll('.thumb-item').forEach(el => el.classList.remove('page-thumb-active'));
            const activeThumb = document.getElementById(`thumb-${num}`);
            if(activeThumb) {
                activeThumb.classList.add('page-thumb-active');
                activeThumb.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            const loadingTask = pdfjsLib.getDocument({data: pdfBytes.slice()});
            const doc = await loadingTask.promise;
            const page = await doc.getPage(num);
            const viewport = page.getViewport({scale: pdfScale});

            canvas.height = viewport.height; canvas.width = viewport.width;
            overlay.height = viewport.height; overlay.width = viewport.width;

            const renderContext = { canvasContext: ctx, viewport: viewport };
            await page.render(renderContext).promise;
            
            selectedAnnIndex = -1;
            updateToolbarForSelection();
            redrawOverlay();
        }

        function redrawOverlay() {
            overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
            const pageAnns = annotations.filter(a => a.page === pageNum);

            pageAnns.forEach((ann, localIdx) => {
                const globalIdx = annotations.indexOf(ann);
                const isSelected = (globalIdx === selectedAnnIndex);

                if (ann.type === 'text') {
                    overlayCtx.font = `${ann.size}px ${getCanvasFont(ann.font)}`;
                    overlayCtx.fillStyle = ann.color;
                    overlayCtx.fillText(ann.content, ann.x, ann.y + ann.size); 
                    ann.w = overlayCtx.measureText(ann.content).width; ann.h = ann.size; 
                } else if (ann.type === 'path') {
                    overlayCtx.beginPath();
                    overlayCtx.strokeStyle = ann.color;
                    overlayCtx.lineWidth = ann.lineWidth || 2;
                    overlayCtx.moveTo(ann.path[0].x, ann.path[0].y);
                    for(let i=1; i<ann.path.length; i++) overlayCtx.lineTo(ann.path[i].x, ann.path[i].y);
                    overlayCtx.stroke();
                    if(isSelected) {
                        let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
                        ann.path.forEach(p => { if(p.x < minX) minX=p.x; if(p.x > maxX) maxX=p.x; if(p.y < minY) minY=p.y; if(p.y > maxY) maxY=p.y; });
                        ann.x=minX; ann.y=minY; ann.w=maxX-minX; ann.h=maxY-minY;
                    }
                } else if (ann.type === 'rect') {
                    overlayCtx.fillStyle = ann.color; overlayCtx.fillRect(ann.x, ann.y, ann.w, ann.h);
                } else if (ann.type === 'image' || ann.type === 'stamp') {
                    if(ann.subtype === 'standard_stamp') {
                        overlayCtx.save();
                        overlayCtx.translate(ann.x + ann.w/2, ann.y + ann.h/2);
                        overlayCtx.beginPath();
                        overlayCtx.strokeStyle = ann.color;
                        overlayCtx.lineWidth = 4;
                        overlayCtx.rect(-ann.w/2, -ann.h/2, ann.w, ann.h);
                        overlayCtx.stroke();
                        overlayCtx.font = `bold ${ann.h * 0.4}px Courier`;
                        overlayCtx.fillStyle = ann.color;
                        overlayCtx.textAlign = 'center';
                        overlayCtx.textBaseline = 'middle';
                        overlayCtx.fillText(ann.content, 0, 0);
                        overlayCtx.restore();
                    } else {
                        const img = new Image(); img.src = ann.dataUrl;
                        overlayCtx.drawImage(img, ann.x, ann.y, ann.w, ann.h);
                    }
                }

                if (isSelected) {
                    overlayCtx.save();
                    overlayCtx.strokeStyle = '#3b82f6'; 
                    overlayCtx.lineWidth = 2;
                    overlayCtx.setLineDash([5, 3]);
                    const pad = 4;
                    overlayCtx.strokeRect(ann.x - pad, ann.y - pad, ann.w + pad*2, ann.h + pad*2);
                    overlayCtx.setLineDash([]);
                    
                    // Resize Handle (Bottom-Right)
                    if(ann.type === 'image' || ann.type === 'stamp') {
                        overlayCtx.fillStyle = '#3b82f6';
                        overlayCtx.fillRect(ann.x + ann.w - 4, ann.y + ann.h - 4, 8, 8);
                    }
                    
                    overlayCtx.restore();
                }
            });
        }

        // --- Interaction Handlers ---
        overlay.addEventListener('mousedown', (e) => {
            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (currentMode === 'cursor') {
                // Check Resize Handle First
                if (selectedAnnIndex !== -1) {
                    const ann = annotations[selectedAnnIndex];
                    if (ann.page === pageNum && (ann.type === 'image' || ann.type === 'stamp')) {
                        const handleSize = 12;
                        if (x >= ann.x + ann.w - 4 && x <= ann.x + ann.w + 8 &&
                            y >= ann.y + ann.h - 4 && y <= ann.y + ann.h + 8) {
                            isResizing = true;
                            dragStart = {x, y};
                            ann.origW = ann.w;
                            ann.origH = ann.h;
                            ann.ratio = ann.w / ann.h;
                            return;
                        }
                    }
                }

                // Check Hit Test
                let hitFound = false;
                for (let i = annotations.length - 1; i >= 0; i--) {
                    const ann = annotations[i];
                    if (ann.page !== pageNum) continue;
                    if (x >= ann.x && x <= ann.x + ann.w && y >= ann.y && y <= ann.y + ann.h) {
                        selectedAnnIndex = i;
                        isDragging = true;
                        dragStart = {x, y};
                        dragOffset = {x: x - ann.x, y: y - ann.y};
                        hitFound = true;
                        updateToolbarForSelection();
                        break;
                    }
                }
                if (!hitFound) { selectedAnnIndex = -1; updateToolbarForSelection(); }
                redrawOverlay();

            } else if (currentMode === 'text') {
                startTextInput(x, y);
            } else if (currentMode === 'draw') {
                saveState();
                isDragging = true; 
                annotations.push({ page: pageNum, type: 'path', color: inputs.pen.value, lineWidth: parseInt(inputs.penWidth.value), path: [{x, y}] });
                selectedAnnIndex = -1;
            } else if (currentMode === 'whiteout') {
                saveState();
                const s = parseInt(inputs.eraser.value);
                annotations.push({ page: pageNum, type: 'rect', x: x - s/2, y: y - s/2, w: s, h: s, color: 'white' });
                redrawOverlay();
            } else if (currentMode === 'place_image' && pendingImage) {
                placePendingImage(x, y);
            }
        });

        overlay.addEventListener('mousemove', (e) => {
            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Handle Resize
            if (currentMode === 'cursor' && isResizing && selectedAnnIndex !== -1) {
                const ann = annotations[selectedAnnIndex];
                const newW = x - ann.x;
                const newH = newW / ann.ratio;
                
                if (newW > 20 && newH > 20) {
                    ann.w = newW;
                    ann.h = newH;
                }
                redrawOverlay();
                overlay.style.cursor = 'nwse-resize';
                return;
            }

            // Handle Move
            if (currentMode === 'cursor' && isDragging && selectedAnnIndex !== -1) {
                const ann = annotations[selectedAnnIndex];
                if(ann.type === 'path') {
                    const dx = x - dragStart.x;
                    const dy = y - dragStart.y;
                    ann.path.forEach(p => { p.x += dx; p.y += dy; });
                    dragStart = {x, y}; 
                    let minX=Infinity, minY=Infinity;
                    ann.path.forEach(p => { if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; });
                    ann.x = minX; ann.y=minY;
                } else {
                    ann.x = x - dragOffset.x;
                    ann.y = y - dragOffset.y;
                }
                redrawOverlay();
                return;
            }
            
            // Cursor Updates
            if(currentMode === 'cursor') {
                if(selectedAnnIndex !== -1) {
                    const ann = annotations[selectedAnnIndex];
                    if ((ann.type === 'image' || ann.type === 'stamp') &&
                        x >= ann.x + ann.w - 4 && x <= ann.x + ann.w + 8 &&
                        y >= ann.y + ann.h - 4 && y <= ann.y + ann.h + 8) {
                        overlay.style.cursor = 'nwse-resize';
                    } else if (x >= ann.x && x <= ann.x + ann.w && y >= ann.y && y <= ann.y + ann.h) {
                        overlay.style.cursor = 'move';
                    } else {
                        overlay.style.cursor = 'default';
                    }
                } else {
                    overlay.style.cursor = 'default';
                }
            }

            if (currentMode === 'draw' && isDragging) {
                const currentPath = annotations[annotations.length - 1];
                currentPath.path.push({x, y});
                redrawOverlay();
            }
        });

        overlay.addEventListener('mouseup', () => { 
            if (isDragging && currentMode === 'cursor' && selectedAnnIndex !== -1) {
                saveState();
            }
            isDragging = false; 
            isResizing = false; 
        });

        overlay.addEventListener('dblclick', (e) => {
            if (currentMode === 'cursor' && selectedAnnIndex !== -1) {
                const ann = annotations[selectedAnnIndex];
                if (ann.type === 'text') startTextInput(ann.x, ann.y, ann);
            }
        });

        // --- Toolbar & Edit Logic ---
        function updateToolbarForSelection() {
            const ann = selectedAnnIndex !== -1 ? annotations[selectedAnnIndex] : null;
            document.querySelectorAll('[id^="prop-"]').forEach(el => { el.classList.remove('flex'); el.classList.add('hidden'); });

            if (currentMode === 'cursor' && ann) {
                if (ann.type === 'text') {
                    const el = document.getElementById('prop-text');
                    el.classList.remove('hidden'); el.classList.add('flex');
                    inputs.font.value = ann.font;
                    inputs.size.value = Math.round(ann.size / pdfScale);
                    inputs.color.value = ann.color;
                    document.getElementById('btn-delete-text').classList.remove('hidden');
                } else if (ann.type === 'stamp' && ann.subtype === 'standard_stamp') {
                    const el = document.getElementById('prop-stamp');
                    el.classList.remove('hidden'); el.classList.add('flex');
                    inputs.stampColor.value = ann.color;
                }
            } else {
                const propId = `prop-${currentMode}`;
                if(document.getElementById(propId)) {
                    document.getElementById(propId).classList.remove('hidden');
                    document.getElementById(propId).classList.add('flex');
                    document.getElementById('btn-delete-text')?.classList.add('hidden');
                } else {
                    document.getElementById('prop-default').classList.remove('hidden');
                    document.getElementById('prop-default').classList.add('flex');
                }
            }
        }

        function updateSelectedTextProp() {
            if (selectedAnnIndex === -1) return;
            const ann = annotations[selectedAnnIndex];
            if (ann.type === 'text') {
                saveState();
                ann.font = inputs.font.value;
                ann.size = parseInt(inputs.size.value) * pdfScale;
                ann.color = inputs.color.value;
                redrawOverlay();
            }
        }

        function updateSelectedStampProp() {
            if (selectedAnnIndex === -1) return;
            const ann = annotations[selectedAnnIndex];
            if (ann.type === 'stamp' && ann.subtype === 'standard_stamp') {
                saveState();
                ann.color = inputs.stampColor.value;
                redrawOverlay();
            }
        }

        function deleteSelectedAnnotation() {
            if(selectedAnnIndex !== -1) {
                saveState();
                annotations.splice(selectedAnnIndex, 1);
                selectedAnnIndex = -1;
                updateToolbarForSelection();
                redrawOverlay();
                showToast('Annotation deleted', 'info');
            }
        }

        let editingAnnIndex = -1;
        function startTextInput(x, y, existingAnn = null) {
            const size = parseInt(inputs.size.value);
            const displaySize = size * pdfScale; 
            textInputContainer.style.left = `${x}px`; textInputContainer.style.top = `${y}px`; textInputContainer.style.display = 'block';
            floatingTextarea.style.fontSize = `${displaySize}px`;
            floatingTextarea.style.fontFamily = getCanvasFont(inputs.font.value);
            floatingTextarea.style.color = inputs.color.value;
            
            if (existingAnn) {
                editingAnnIndex = annotations.indexOf(existingAnn);
                floatingTextarea.value = existingAnn.content;
            } else {
                editingAnnIndex = -1; floatingTextarea.value = '';
                textInputContainer.dataset.x = x; textInputContainer.dataset.y = y;
            }
            setTimeout(() => floatingTextarea.focus(), 50);
        }

        function finalizeTextInput() {
            if (textInputContainer.style.display === 'none') return;
            const content = floatingTextarea.value.trim();
            if (content) {
                saveState();
                const baseSize = parseInt(inputs.size.value) * pdfScale;
                if (editingAnnIndex !== -1) {
                    const ann = annotations[editingAnnIndex];
                    ann.content = content;
                } else {
                    const x = parseFloat(textInputContainer.dataset.x);
                    const y = parseFloat(textInputContainer.dataset.y);
                    overlayCtx.font = `${baseSize}px ${getCanvasFont(inputs.font.value)}`;
                    const w = overlayCtx.measureText(content).width;
                    annotations.push({ page: pageNum, type: 'text', x: x, y: y, w: w, h: baseSize, content: content, size: baseSize, font: inputs.font.value, color: inputs.color.value });
                }
                redrawOverlay();
            } else if (editingAnnIndex !== -1) {
                saveState();
                annotations.splice(editingAnnIndex, 1);
                redrawOverlay();
            }
            cancelTextInput();
        }

        function cancelTextInput() {
            textInputContainer.style.display = 'none'; floatingTextarea.value = ''; editingAnnIndex = -1;
        }

        // --- Stamps ---
        function toggleStampMenu() {
            document.getElementById('stamp-menu').classList.toggle('hidden');
        }
        window.onclick = function(e) {
            if (!e.target.closest('#btn-stamp') && !e.target.closest('#stamp-menu')) {
                document.getElementById('stamp-menu').classList.add('hidden');
            }
        }

        function addStamp(text, color) {
            saveState();
            const w = 150 * pdfScale; const h = 50 * pdfScale;
            const x = (canvas.width / 2) - (w/2); const y = (canvas.height / 2) - (h/2);
            annotations.push({ page: pageNum, type: 'stamp', subtype: 'standard_stamp', x: x, y: y, w: w, h: h, content: text, color: color });
            redrawOverlay();
            setMode('cursor'); 
            selectedAnnIndex = annotations.length - 1;
            updateToolbarForSelection();
            document.getElementById('stamp-menu').classList.add('hidden');
            showToast('Stamp added', 'success');
        }

        function handleStampUpload(e) {
            const file = e.target.files[0]; if(!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => {
                    pendingImage = img;
                    setMode('place_image');
                    showToast('Click on PDF to place stamp', 'info');
                    document.getElementById('stamp-menu').classList.add('hidden');
                };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file); e.target.value = '';
        }

        // --- Helpers ---
        function setMode(mode) {
            currentMode = mode;
            if(textInputContainer.style.display === 'block') finalizeTextInput();
            
            document.querySelectorAll('#toolbar button').forEach(btn => btn.classList.remove('tool-active'));
            if(mode !== 'stamp' && mode !== 'place_image' && document.getElementById(`btn-${mode}`)) {
                document.getElementById(`btn-${mode}`).classList.add('tool-active');
            }

            if(mode !== 'cursor') { selectedAnnIndex = -1; redrawOverlay(); }
            updateToolbarForSelection();

            if (mode === 'text') overlay.style.cursor = 'text';
            else if (mode === 'draw' || mode === 'whiteout') overlay.style.cursor = 'crosshair';
            else if (mode === 'place_image') overlay.style.cursor = 'crosshair';
            else overlay.style.cursor = 'default';

            // Update hint
            const hints = {
                cursor: 'Cursor Mode: Drag to move. Drag blue corner to resize. Double click text to edit.',
                text: 'Text Mode: Click to add text.',
                draw: 'Draw Mode: Click and drag to draw.',
                whiteout: 'Eraser Mode: Click to erase.',
                place_image: 'Image Mode: Click to place image.'
            };
            document.getElementById('tool-hint').textContent = hints[mode] || '';
        }
        
        function getCanvasFont(name) { return name === 'Times-Roman' ? 'serif' : name === 'Courier' ? 'monospace' : 'sans-serif'; }

        // --- Navigation ---
        function nextPage() {
            if (pageNum < totalPages) renderPage(pageNum + 1);
        }

        function prevPage() {
            if (pageNum > 1) renderPage(pageNum - 1);
        }

        // --- Sidebar & Save ---
        async function renderSidebar(){
             const container = document.getElementById('thumbnail-container'); container.innerHTML = ''; 
             const doc = await pdfjsLib.getDocument({data: pdfBytes.slice()}).promise;
             for(let i=1; i<=totalPages; i++){
                 const d=document.createElement('div'); 
                 d.className='thumb-item bg-white p-2 rounded border border-gray-200 cursor-pointer mb-2 relative group'; 
                 d.id=`thumb-${i}`; 
                 d.onclick=(e)=>{
                     if(e.target.closest('button')) return;
                     renderPage(i);
                 };

                 const c=document.createElement('canvas'); 
                 c.className='w-full border mb-1'; 
                 d.appendChild(c);

                 const controls = document.createElement('div');
                 controls.className = "flex justify-between items-center px-1";
                 controls.innerHTML += `<div class='text-xs font-bold text-gray-500'>Page ${i}</div>`;
                 
                 const btnGroup = document.createElement('div');
                 btnGroup.className = "flex space-x-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200";

                 const btnRot = document.createElement('button');
                 btnRot.className = "p-1 hover:bg-blue-100 rounded text-blue-600 transition";
                 btnRot.title = "Rotate";
                 btnRot.innerHTML = `<i data-lucide="rotate-cw" class="w-3 h-3"></i>`;
                 btnRot.onclick = () => rotateSpecificPage(i);

                 const btnDel = document.createElement('button');
                 btnDel.className = "p-1 hover:bg-red-100 rounded text-red-600 transition";
                 btnDel.title = "Delete";
                 btnDel.innerHTML = `<i data-lucide="trash-2" class="w-3 h-3"></i>`;
                 btnDel.onclick = () => deleteSpecificPage(i);

                 btnGroup.appendChild(btnRot);
                 btnGroup.appendChild(btnDel);
                 controls.appendChild(btnGroup);

                 d.appendChild(controls);
                 container.appendChild(d);

                 doc.getPage(i).then(p=>{const v=p.getViewport({scale:0.2});c.width=v.width;c.height=v.height;p.render({canvasContext:c.getContext('2d'),viewport:v})});
             }
             lucide.createIcons();
        }
        
        async function handleFileUpload(e){
            const f=e.target.files[0];
            if(!f) return;
            const r=new FileReader();
            r.onload=async(ev)=>{
                pdfBytes=new Uint8Array(ev.target.result);
                await initPdf();
            };
            r.readAsArrayBuffer(f);
        }
        
        async function zoomIn(){
            if(pdfScale<3){
                pdfScale+=0.25;
                updateZoomDisplay();
                await renderPage(pageNum);
            }
        }
        
        async function zoomOut(){
            if(pdfScale>0.5){
                pdfScale-=0.25;
                updateZoomDisplay();
                await renderPage(pageNum);
            }
        }
        
        function updateZoomDisplay(){
            zoomDisplay.textContent=Math.round(pdfScale*100)+'%';
        }
        
        function toggleSidebar(){
            isSidebarOpen=!isSidebarOpen;
            sidebarPanel.classList.toggle('hidden');
            sidebarPanel.classList.toggle('flex');
        }

        function openSignatureModal(){
            document.getElementById('signature-modal').classList.remove('hidden');
            const c=document.getElementById('signature-pad');
            c.width=c.offsetWidth;
            c.height=c.offsetHeight;
            signaturePad=new SignaturePad(c,{backgroundColor:'rgba(0,0,0,0)'});
        }
        
        function closeSignatureModal(){
            document.getElementById('signature-modal').classList.add('hidden');
        }
        
        function clearSignature(){
            signaturePad.clear();
        }
        
        function saveSignature(){
            if(signaturePad.isEmpty()) return;
            const img=new Image();
            img.onload=()=>{
                pendingImage=img;
                closeSignatureModal();
                setMode('place_image');
                showToast('Click on PDF to place signature', 'info');
            };
            img.src=signaturePad.toDataURL();
        }
        
        function handleImageUpload(e){
            const f=e.target.files[0];
            if(!f) return;
            const r=new FileReader();
            r.onload=(ev)=>{
                const img=new Image();
                img.onload=()=>{
                    pendingImage=img;
                    setMode('place_image');
                    showToast('Click on PDF to place image', 'info');
                };
                img.src=ev.target.result;
            };
            r.readAsDataURL(f);
            e.target.value='';
        }
        
        function placePendingImage(x,y){
            saveState();
            let w=pendingImage.width, h=pendingImage.height, max=200*pdfScale;
            if(w>max||h>max){
                const r=w/h;
                if(w>h){w=max;h=w/r;}
                else{h=max;w=h*r;}
            }
            annotations.push({page:pageNum,type:'image',x:x-w/2,y:y-h/2,w:w,h:h,dataUrl:pendingImage.src});
            redrawOverlay();
            pendingImage=null;
            setMode('cursor');
            selectedAnnIndex=annotations.length-1;
            updateToolbarForSelection();
            showToast('Image placed', 'success');
        }
        
        // Page Operations
        function promptInsertBlank() {
            const pos = prompt("Insert blank page AFTER page number?", pageNum);
            if(pos === null) return;
            const index = parseInt(pos);
            if(isNaN(index) || index < 0 || index > totalPages) return alert("Invalid page number");
            insertBlankPageAt(index);
        }

        async function insertBlankPageAt(index) {
            toggleLoader(true);
            const { width, height } = pdfDoc.getPage(0).getSize();
            pdfDoc.insertPage(index, [width, height]);
            await updatePdfBytes();
            pageNum = index + 1; 
            await renderPage(pageNum);
            await renderSidebar();
            toggleLoader(false);
            showToast('Blank page inserted', 'success');
        }

        function promptInsertPdf() {
            document.getElementById('insert-after-page').value = pageNum;
            document.getElementById('insert-range').value = ''; 
            document.getElementById('insert-pdf-modal').classList.remove('hidden');
        }

        async function handleInsertPdfUpload(event) {
            const file = event.target.files[0];
            if(!file) return;
            document.getElementById('insert-pdf-modal').classList.add('hidden');
            toggleLoader(true, "Merging PDF...");

            const rangeStr = document.getElementById('insert-range').value.trim();
            const insertAfter = parseInt(document.getElementById('insert-after-page').value) || pageNum;
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                const srcDoc = await PDFDocument.load(arrayBuffer);
                const srcTotal = srcDoc.getPageCount();
                let indices = [];
                if(!rangeStr) {
                    indices = srcDoc.getPageIndices();
                } else {
                    const parts = rangeStr.split(',');
                    parts.forEach(p => {
                        if(p.includes('-')) {
                            const [start, end] = p.split('-').map(n => parseInt(n));
                            for(let i=start; i<=end; i++) indices.push(i-1);
                        } else { indices.push(parseInt(p)-1); }
                    });
                    indices = indices.filter(i => i >= 0 && i < srcTotal);
                }
                if(indices.length === 0) throw new Error("No valid pages selected.");

                const copiedPages = await pdfDoc.copyPages(srcDoc, indices);
                let currIndex = insertAfter;
                for (const page of copiedPages) { pdfDoc.insertPage(currIndex, page); currIndex++; }
                await updatePdfBytes();
                pageNum = insertAfter + 1;
                await renderPage(pageNum);
                await renderSidebar();
                showToast(`Successfully inserted ${indices.length} pages`, 'success');
            } catch (err) { 
                showToast('Failed to insert PDF: ' + err.message, 'error');
            }
            toggleLoader(false); event.target.value = ''; 
        }

        async function updatePdfBytes() { 
            totalPages = pdfDoc.getPageCount(); 
            pdfBytes = await pdfDoc.save(); 
        }
        
        async function rotateSpecificPage(i) {
            toggleLoader(true, "Rotating..."); 
            const p = pdfDoc.getPage(i-1); 
            p.setRotation(degrees(p.getRotation().angle+90));
            await updatePdfBytes(); 
            if(pageNum===i) await renderPage(i); 
            await renderSidebar(); 
            toggleLoader(false);
            showToast('Page rotated', 'success');
        }
        
        async function deleteSpecificPage(i) {
            if(totalPages<=1) return showToast('Cannot delete the only page', 'error');
            if(!confirm(`Delete page ${i}?`)) return;
            toggleLoader(true, "Deleting..."); 
            pdfDoc.removePage(i-1); 
            if(pageNum>=i) pageNum=Math.max(1, pageNum-1);
            await updatePdfBytes(); 
            await renderPage(pageNum); 
            await renderSidebar(); 
            toggleLoader(false);
            showToast('Page deleted', 'success');
        }
        
        function toggleLoader(show, text="Processing...") {
            document.getElementById('loading-overlay').classList.toggle('hidden', !show);
            if(text) document.getElementById('loading-text').textContent = text;
        }

        // Helper to convert hex color to RGB object
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return { r, g, b };
        }

        async function savePdf() {
            if (!pdfDoc) return;
            toggleLoader(true, "Saving PDF...");
            
            try {
                const pdfDocSave = await PDFDocument.load(pdfBytes);
                const fontRef = { 
                    'Helvetica': await pdfDocSave.embedFont(StandardFonts.Helvetica), 
                    'Times-Roman': await pdfDocSave.embedFont(StandardFonts.TimesRoman), 
                    'Courier': await pdfDocSave.embedFont(StandardFonts.Courier) 
                };
                const pages = pdfDocSave.getPages();
                
                for (let ann of annotations) {
                    if(ann.page > pages.length) continue;
                    const page = pages[ann.page - 1];
                    const { width, height } = page.getSize();
                    
                    const scaleX = width / canvas.width; 
                    const scaleY = height / canvas.height;
                    const pdfX = ann.x * scaleX; 
                    const pdfY = height - (ann.y * scaleY);

                    if (ann.type === 'text') {
                        const fontSize = (ann.size * scaleY) * 0.8; 
                        const { r, g, b } = hexToRgb(ann.color);
                        page.drawText(ann.content, { 
                            x: pdfX, 
                            y: pdfY - fontSize, 
                            size: fontSize, 
                            font: fontRef[ann.font], 
                            color: rgb(r, g, b) 
                        });
                    } else if (ann.type === 'rect') {
                        page.drawRectangle({ 
                            x: pdfX, 
                            y: pdfY - (ann.h * scaleY), 
                            width: ann.w * scaleX, 
                            height: ann.h * scaleY, 
                            color: rgb(1, 1, 1) 
                        });
                    } else if (ann.type === 'image' || ann.type === 'stamp') {
                        if(ann.subtype === 'standard_stamp') {
                            const { r, g, b } = hexToRgb(ann.color);
                            const col = rgb(r, g, b);
                            page.drawRectangle({ 
                                x: pdfX, 
                                y: pdfY - (ann.h * scaleY), 
                                width: ann.w * scaleX, 
                                height: ann.h * scaleY, 
                                borderColor: col, 
                                borderWidth: 3 
                            });
                            const txtSize = (ann.h * scaleY) * 0.4;
                            const font = await pdfDocSave.embedFont(StandardFonts.CourierBold);
                            const txtW = font.widthOfTextAtSize(ann.content, txtSize);
                            page.drawText(ann.content, { 
                                x: pdfX + (ann.w * scaleX - txtW) / 2, 
                                y: pdfY - (ann.h * scaleY) + (ann.h * scaleY - txtSize) / 2, 
                                size: txtSize, 
                                font: font, 
                                color: col 
                            });
                        } else {
                            try {
                                let imgEmbed; 
                                if(ann.dataUrl.startsWith('data:image/png')) 
                                    imgEmbed = await pdfDocSave.embedPng(ann.dataUrl); 
                                else 
                                    imgEmbed = await pdfDocSave.embedJpg(ann.dataUrl);
                                page.drawImage(imgEmbed, { 
                                    x: pdfX, 
                                    y: pdfY - (ann.h * scaleY), 
                                    width: ann.w * scaleX, 
                                    height: ann.h * scaleY 
                                });
                            } catch(err) {
                                console.error("Failed to embed image/signature", err);
                                showToast("Warning: One or more images failed to save", 'error');
                            }
                        }
                    } else if (ann.type === 'path') {
                        const { r, g, b } = hexToRgb(ann.color);
                        for(let i = 1; i < ann.path.length; i++) {
                            const s = ann.path[i-1]; 
                            const e = ann.path[i];
                            page.drawLine({ 
                                start: { x: s.x * scaleX, y: height - (s.y * scaleY) }, 
                                end: { x: e.x * scaleX, y: height - (e.y * scaleY) }, 
                                thickness: (ann.lineWidth || 2) * scaleY, 
                                color: rgb(r, g, b) 
                            });
                        }
                    }
                }
                const outBytes = await pdfDocSave.save();
                download(outBytes, "Edited_WebPDF.pdf", "application/pdf");
                showToast('PDF saved successfully!', 'success');
            } catch (e) {
                showToast('Error saving PDF: ' + e.message, 'error');
                console.error(e);
            }
            toggleLoader(false);
        }
    </script>
</body>
</html>
